[
  {
    "name": "Characters I",
    "commands": [
      {
        "key": ".",
        "description": "Match any character except newline"
      },
      {
        "key": "^",
        "description": "Match the start of the string"
      },
      {
        "key": "$",
        "description": "Match the end of the string"
      },
      {
        "key": "*",
        "description": "Match 0 or more repetitions"
      },
      {
        "key": "+",
        "description": "Match 1 or more repetitions"
      },
      {
        "key": "?",
        "description": "Match 0 or 1 repetitions"
      }
    ]
  },
  {
    "name": "Special Sequences I",
    "commands": [
      {
        "key": "\\A",
        "description": "Match only at start of string"
      },
      {
        "key": "\\b",
        "description": "Match empty string, only at beginning or end of a word"
      },
      {
        "key": "\\B",
        "description": "Match empty string, only when it is not at beginning or end of word"
      },
      {
        "key": "\\d",
        "description": "Match digits # same as [0-9]"
      },
      {
        "key": "\\D",
        "description": "Match any non digit # same as [^0-9]"
      }
    ]
  },
  {
    "name": "Characters II",
    "commands": [
      {
        "key": "*?",
        "description": "Match 0 or more repetitions non-greedy"
      },
      {
        "key": "+?",
        "description": "Match 1 or more repeitions non-greedy"
      },
      {
        "key": "??",
        "description": "Match 0 or 1 repetitions non-greedy"
      },
      {
        "key": "\\",
        "description": "Escape special characters"
      },
      {
        "key": "[]",
        "description": "Match a set of characters"
      },
      {
        "key": "[a-z]",
        "description": "Match any lowercase ASCII letter"
      },
      {
        "key": "[lower-upper]",
        "description": "Match a set of characters from lower to upper"
      },
      {
        "key": "[^]",
        "description": "Match characters NOT in a set"
      },
      {
        "key": "A|B",
        "description": "Match either A or B regular expressions (non-greedy)"
      }
    ]
  },
  {
    "name": "Special Sequences II",
    "commands": [
      {
        "key": "\\s",
        "description": "Match whitespace characters # same as [ \\t\\n\\r\\f\\v]"
      },
      {
        "key": "\\S",
        "description": "Match non whitespace characters #same as [^ \\t\\n\\r\\f\\v]"
      },
      {
        "key": "\\w",
        "description": "Match unicode word characters # same as [a-zA-Z0-9_]"
      },
      {
        "key": "\\W",
        "description": "Match any character not a Unicode word character # same as [^a-zA-Z0-9_]"
      },
      {
        "key": "\\Z",
        "description": "Match only at end of string"
      }
    ]
  },
  {
    "name": "Characters III",
    "commands": [
      {
        "key": "{m}",
        "description": "Match exactly m copies"
      },
      {
        "key": "{m,n}",
        "description": "Match from m to n repetitions"
      },
      {
        "key": "{,n}",
        "description": "Match from 0 to n repetitions"
      },
      {
        "key": "{m,}",
        "description": "Match from m to infinite repetitions"
      },
      {
        "key": "{m,n}?",
        "description": "Match from m to n repetitions non-greedy (as few as possible)"
      }
    ]
  },
  {
    "name": "RE Methods I",
    "commands": [
      {
        "key": "re.compile(pattern,flags)",
        "description": "Compile a regular expression of pattern, with flags"
      },
      {
        "key": "re.match(pattern,string)",
        "description": "Match pattern only at beginning of string"
      },
      {
        "key": "re.search(pattern,string)",
        "description": "Match pattern anywhere in the string"
      },
      {
        "key": "re.split(pattern,string)",
        "description": "Split string by occurrences of patern"
      },
      {
        "key": "re.sub(pattern,str2,string)",
        "description": "Replace leftmost non-overlapping occurrences of pattern in string with str2"
      }
    ]
  },
  {
    "name": "Groups I",
    "commands": [
      {
        "key": "(match)",
        "description": "Use to specify a group for which match can be retrieved later"
      },
      {
        "key": "(?:match)",
        "description": "Non-capturing version parenthesis (match cannot be retrieved later)"
      },
      {
        "key": "(?P<name>)",
        "description": "Capture group with name \"name\""
      },
      {
        "key": "(?P=name)",
        "description": "Back reference group named \"name\" in same pattern"
      },
      {
        "key": "(?#comment)",
        "description": "Comment"
      }
    ]
  },
  {
    "name": "Match Objects I",
    "commands": [
      {
        "key": "match.group(\"name\")",
        "description": "Return subgroup \"name\" of match"
      },
      {
        "key": "match.groups()",
        "description": "Return tuple containing all subgroups of match"
      },
      {
        "key": "match.groupdict()",
        "description": "Return dict containing all named subgroups of match"
      },
      {
        "key": "match.start(group)",
        "description": "Return start index of substring match by group"
      },
      {
        "key": "match.end(group)",
        "description": "Return end index of substring matched by group"
      },
      {
        "key": "match.span(group)",
        "description": "Return 2-tuple start and end indices of group in match"
      }
    ]
  },
  {
    "name": "Flags I",
    "commands": [
      {
        "key": "(?)",
        "description": "Extension notation (used to set flags)"
      },
      {
        "key": "a",
        "description": "ASCII-only matching flag"
      },
      {
        "key": "i",
        "description": "Ignore case flag"
      },
      {
        "key": "L",
        "description": "Locale dependent flag"
      },
      {
        "key": "m",
        "description": "Multi-line flag"
      },
      {
        "key": "s",
        "description": "Dot matches all flag"
      },
      {
        "key": "x",
        "description": "Verbose flag"
      }
    ]
  },
  {
    "name": "Lookahead / Behind I",
    "commands": [
      {
        "key": "(?=match)",
        "description": "Lookahead assertion - match if contents matches next, but don't consume any of the string."
      },
      {
        "key": "(?!match)",
        "description": "Negative lookahead assertion - match if contents do not match next"
      },
      {
        "key": "(?<=match)",
        "description": "Positive lookbehind assertion - match if current position in string is preceded by match"
      },
      {
        "key": "(?<!match)",
        "description": "Negative lookbehind assertion - match if current position is not preceded by match"
      },
      {
        "key": "(?(id/name)yes|no)",
        "description": "Match \"yes\" pattern if id or name exists, otherwise match \"no\" pattern"
      }
    ]
  },
  {
    "name": "Match Objects II",
    "commands": [
      {
        "key": "match.pos",
        "description": "Value of pos which was passed to search() or match()"
      },
      {
        "key": "match.endpos",
        "description": "Value of endpos which was passed to search() or match()"
      },
      {
        "key": "match.lastindex",
        "description": "Integer index of last matched capturing group"
      },
      {
        "key": "match.lastgroup",
        "description": "Name of last matched capturing group"
      },
      {
        "key": "match.re",
        "description": "The regular expression who match() or search() created this match"
      },
      {
        "key": "match.string",
        "description": "The string passed to match() or search()"
      }
    ]
  },
  {
    "name": "RE Methods II",
    "commands": [
      {
        "key": "re.fullmatch(pattern,string)",
        "description": "Match pattern if whole string matches regular expression"
      },
      {
        "key": "re.findall(pattern,string)",
        "description": "Return all non-overlapping matches of pattern in string, as a list of strings"
      },
      {
        "key": "re.finditer(pattern,string)",
        "description": "Return an iterator yielding match objects over non-overlapping matches of pattern in string"
      },
      {
        "key": "re.subn(pattern,str2,string)",
        "description": "Replace left most occurrences of pattern in string with str2, but return a tuple of (newstring, # subs made)"
      },
      {
        "key": "re.purge()",
        "description": "Clear the regular expression cache"
      }
    ]
  }
]